{"version":3,"sources":["serviceWorker.ts","consts/Tiles.ts","GameScene/update.ts","utils/assert.ts","GameScene/create.ts","GameScene/GameScene.ts","Game/scenes/LevelFinishedScene.ts","Game/Game.ts"],"names":["Boolean","window","location","hostname","match","Tiles","BoxToTargetColorMap","BoxOrange","TargetOrange","BoxRed","TargetRed","BoxBlue","TargetBlue","BoxGreen","TargetGreen","BoxGrey","TargetGrey","BoxColors","targetsCoveredByColor","reduce","prev","color","movesCount","move","elements","updateUtils","anims","player","tweenMove","tweenMoveCurry","cursors","JustDown","Phaser","Input","Keyboard","justLeft","left","justRight","right","justUp","up","justDown","down","MOVE_LEFT","MOVE_RIGHT","MOVE_UP","MOVE_DOWN","currentAnim","stopPlayerAnimation","handleArrowPress","absoluteMove","x","centerMove","TILE_SIZE","y","direction","world","boxesByColor","tweens","scene","getBoxAt","getBoxAtCurry","hasWallAt","hasWallAtCurry","hasTargetAt","hasTargetAtCurry","moves","newPlayerCenterX","newPlayerCenterY","boxData","box","newBoxCenterX","newBoxCenterY","boxTarget","changeTargetCoveredCountForColor","add","duration","targets","onComplete","allTargetsCovered","console","log","start","onCompleteBoxMove","movesCountText","text","onStart","play","movePlayer","Object","entries","find","getBounds","contains","Number","tile","getTileAtWorldXY","index","Wall","tileToFind","key","startsWith","change","values","every","count","assert","value","Error","extractBoxes","boxColor","createFromTiles","frame","map","setOrigin","GameScene","preload","load","spritesheet","frameWidth","startFrame","input","keyboard","createCursorKeys","create","phaserUtils","level","Player","make","tilemap","data","tileWidth","tileHeight","tiles","addTilesetImage","createStaticLayer","pop","frames","generateFrameNumbers","end","frameRate","repeat","createPlayerAnimations","update","isTweening","Scene","LevelFinishedScene","this","scale","width","height","fontSize","config","type","AUTO","physics","default","arcade","gravity","debug","parent","Game","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.cb16bfa9.chunk.js","sourcesContent":["// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","export enum Tiles {\n  BoxOrange = 6,\n  BoxRed = 7,\n  BoxBlue = 8,\n  BoxGreen = 9,\n  BoxGrey = 10,\n\n  Player = 52,\n\n  TargetOrange = 25,\n  TargetRed = 38,\n  TargetBlue = 51,\n  TargetGreen = 64,\n  TargetGrey = 77,\n\n  Wall = 100,\n}\n\nexport const BoxToTargetColorMap: { [key: string]: Tiles } = {\n  [Tiles.BoxOrange]: Tiles.TargetOrange,\n  [Tiles.BoxRed]: Tiles.TargetRed,\n  [Tiles.BoxBlue]: Tiles.TargetBlue,\n  [Tiles.BoxGreen]: Tiles.TargetGreen,\n  [Tiles.BoxGrey]: Tiles.TargetGrey,\n};\n\nexport const BoxColors = [\n  Tiles.BoxOrange,\n  Tiles.BoxRed,\n  Tiles.BoxBlue,\n  Tiles.BoxGreen,\n  Tiles.BoxGrey,\n];\n\nexport const TILE_SIZE = 64;\nexport const TILE_CENTER = TILE_SIZE / 2;\nexport const TILE_CENTER_AFTER_MOVE = TILE_SIZE + TILE_CENTER;\n","import { Elements, BoxesByColor, UpdateUtils } from \"./GameScene\";\nimport {\n  Tiles,\n  BoxToTargetColorMap,\n  TILE_SIZE,\n  TILE_CENTER,\n  TILE_CENTER_AFTER_MOVE,\n  BoxColors,\n} from \"../consts/Tiles\";\n\nconst targetsCoveredByColor = BoxColors.reduce<{ [boxColor: number]: number }>(\n  (prev, color) => {\n    prev[color] = 0;\n    return prev;\n  },\n  {}\n);\n\nlet movesCount: number = 0;\n\nexport const update = ({\n  elements,\n  updateUtils,\n}: {\n  elements: Elements;\n  updateUtils: UpdateUtils;\n}) => {\n  if (updateUtils.tweens.isTweening(elements.player)) {\n    return;\n  }\n  move(elements, updateUtils);\n};\n\ninterface CenterMove {\n  x: number;\n  y: number;\n}\n\ninterface AbsoluteMove {\n  x?: string;\n  y?: string;\n}\n\ninterface Moves {\n  absoluteMove: AbsoluteMove;\n  centerMove: CenterMove;\n  direction: string;\n}\n\nconst move = (elements: Elements, updateUtils: UpdateUtils) => {\n  const {\n    player: { anims },\n  } = elements;\n  const tweenMove = tweenMoveCurry(elements, updateUtils);\n\n  handleArrowPress(updateUtils.cursors, tweenMove, anims);\n};\n\nconst MOVE_LEFT: Moves = {\n  absoluteMove: { x: \"-=\" + TILE_SIZE },\n  centerMove: { x: -TILE_CENTER, y: TILE_CENTER },\n  direction: \"left\",\n};\nconst MOVE_RIGHT: Moves = {\n  absoluteMove: { x: `+=${TILE_SIZE}` },\n  centerMove: { x: TILE_CENTER_AFTER_MOVE, y: TILE_CENTER },\n  direction: \"right\",\n};\nconst MOVE_UP: Moves = {\n  absoluteMove: { y: \"-=\" + TILE_SIZE },\n  centerMove: { x: TILE_CENTER, y: -TILE_CENTER },\n  direction: \"up\",\n};\nconst MOVE_DOWN: Moves = {\n  absoluteMove: { y: \"+=\" + TILE_SIZE },\n  centerMove: { x: TILE_CENTER, y: TILE_CENTER_AFTER_MOVE },\n  direction: \"down\",\n};\n\nfunction handleArrowPress(\n  this: any,\n  cursors: Phaser.Types.Input.Keyboard.CursorKeys,\n  tweenMove: (moves: Moves) => void,\n  anims: Phaser.GameObjects.Components.Animation\n) {\n  const { JustDown } = Phaser.Input.Keyboard;\n  const justLeft = JustDown(cursors.left!);\n  const justRight = JustDown(cursors.right!);\n  const justUp = JustDown(cursors.up!);\n  const justDown = JustDown(cursors.down!);\n  if (justLeft) {\n    tweenMove(MOVE_LEFT);\n  } else if (justRight) {\n    tweenMove(MOVE_RIGHT);\n  } else if (justUp) {\n    tweenMove(MOVE_UP);\n  } else if (justDown) {\n    tweenMove(MOVE_DOWN);\n  } else if (anims.currentAnim) {\n    stopPlayerAnimation(anims);\n  }\n}\n\ninterface BoxData {\n  box: Phaser.GameObjects.Sprite;\n  color: number;\n}\n\nconst tweenMoveCurry = (elements: Elements, updateUtils: UpdateUtils) => {\n  const { player, world, boxesByColor } = elements;\n  const { tweens, scene } = updateUtils;\n\n  const getBoxAt = getBoxAtCurry(boxesByColor);\n  const hasWallAt = hasWallAtCurry(world);\n  const hasTargetAt = hasTargetAtCurry(world);\n\n  return (moves: Moves) => {\n    const newPlayerCenterX = player.x + moves.centerMove.x;\n    const newPlayerCenterY = player.y + moves.centerMove.y;\n\n    if (hasWallAt(newPlayerCenterX, newPlayerCenterY)) {\n      return;\n    }\n    const boxData = getBoxAt(newPlayerCenterX, newPlayerCenterY);\n    if (boxData) {\n      const { box, color } = boxData;\n      const newBoxCenterX = box.x + moves.centerMove.x;\n      const newBoxCenterY = box.y + moves.centerMove.y;\n      if (\n        hasWallAt(newBoxCenterX, newBoxCenterY) ||\n        getBoxAt(newBoxCenterX, newBoxCenterY)\n      ) {\n        return;\n      }\n      const boxTarget = BoxToTargetColorMap[color];\n      const coveredTarget = hasTargetAt(box.x, box.y, boxTarget);\n      if (coveredTarget) {\n        changeTargetCoveredCountForColor(color, -1);\n      }\n\n      const onCompleteBoxMove = (boxData: BoxData) => {\n        const { box, color } = boxData;\n        const boxTarget = BoxToTargetColorMap[color];\n        const coveredTarget = hasTargetAt(box.x, box.y, boxTarget);\n        if (coveredTarget) {\n          changeTargetCoveredCountForColor(color, 1);\n          if (allTargetsCovered()) {\n            console.log(\"you won woho\");\n            scene.start(\"level-finished\", {\n              moves: movesCount,\n            });\n          }\n        }\n      };\n\n      tweens.add({\n        ...moves.absoluteMove,\n        duration: 500,\n        targets: box,\n        onComplete: () => {\n          onCompleteBoxMove(boxData);\n        },\n      });\n    }\n\n    movePlayer(elements, tweens, moves);\n  };\n};\n\nconst getBoxAtCurry = (boxesByColor: BoxesByColor) => (\n  x: number,\n  y: number\n): undefined | { box: Phaser.GameObjects.Sprite; color: number } => {\n  const boxesByColorArray: [\n    string,\n    Phaser.GameObjects.Sprite[]\n  ][] = Object.entries(boxesByColor);\n\n  for (const [color, boxes] of boxesByColorArray) {\n    const box = boxes.find((box) => {\n      const rect = box.getBounds();\n      const playerIsOnBox = rect.contains(x, y);\n      return playerIsOnBox;\n    });\n    if (box) {\n      return { box, color: Number(color) };\n    }\n  }\n  return undefined;\n};\n\nconst hasWallAtCurry = (world: Phaser.Tilemaps.StaticTilemapLayer) => (\n  x: number,\n  y: number\n) => {\n  const tile = world.getTileAtWorldXY(x, y);\n  if (!tile) {\n    return false;\n  }\n\n  return tile.index === Tiles.Wall;\n};\n\nconst hasTargetAtCurry = (world: Phaser.Tilemaps.StaticTilemapLayer) => (\n  x: number,\n  y: number,\n  tileToFind: Tiles\n) => {\n  const tile = world.getTileAtWorldXY(x, y);\n  if (!tile) {\n    return false;\n  }\n\n  return tile.index === tileToFind;\n};\n\nconst updateMovesCountText = (countText: Phaser.GameObjects.Text) => {\n  countText.text = `Moves: ${movesCount}`;\n};\n\nconst stopPlayerAnimation = (\n  anims: Phaser.GameObjects.Components.Animation\n) => {\n  const {\n    currentAnim: { key },\n  } = anims;\n  if (!key.startsWith(\"idle-\")) {\n    anims.play(`idle-${key}`, true);\n  }\n};\n\nconst changeTargetCoveredCountForColor = (color: Tiles, change: number) => {\n  targetsCoveredByColor[color] += change;\n};\n\nconst allTargetsCovered = () => {\n  return Object.values(targetsCoveredByColor).every((count) => count === 1);\n};\nfunction movePlayer(\n  elements: Elements,\n  tweens: Phaser.Tweens.TweenManager,\n  moves: Moves\n) {\n  const { player } = elements;\n  const {\n    player: { anims },\n  } = elements;\n  tweens.add({\n    ...moves.absoluteMove,\n    duration: 500,\n    targets: player,\n    onComplete: () => {\n      stopPlayerAnimation(anims);\n      movesCount++;\n      updateMovesCountText(elements.movesCountText);\n    },\n    onStart: () => {\n      anims.play(moves.direction, true);\n    },\n  });\n}\n","export function assert(value: unknown): asserts value {\n  if (!value) {\n    throw new Error(\"errr\");\n  }\n}\n","import Phaser from \"phaser\";\nimport { assert } from \"../utils/assert\";\nimport { Elements, BoxesByColor, CreateUtils } from \"./GameScene\";\nimport { Tiles, BoxColors } from \"../consts/Tiles\";\n\nexport function create(phaserUtils: CreateUtils): Elements {\n  const level = [\n    [100, 100, 100, 100, 100, 100, 100, 100, 100, 100],\n    [100, 0, 0, 0, 0, 0, 0, 0, 0, 100],\n    [\n      100,\n      Tiles.BoxOrange,\n      Tiles.BoxRed,\n      Tiles.BoxBlue,\n      Tiles.BoxGreen,\n      Tiles.BoxGrey,\n      0,\n      0,\n      0,\n      100,\n    ],\n    [\n      100,\n      Tiles.TargetOrange,\n      Tiles.TargetRed,\n      Tiles.TargetBlue,\n      Tiles.TargetGreen,\n      Tiles.TargetGrey,\n      Tiles.Player,\n      0,\n      0,\n      100,\n    ],\n    [100, 0, 0, 0, 0, 0, 0, 0, 0, 100],\n    [100, 0, 0, 0, 0, 0, 0, 0, 0, 100],\n    [100, 0, 0, 0, 0, 0, 0, 0, 0, 100],\n    [100, 100, 100, 100, 100, 100, 100, 100, 100, 100],\n  ];\n  const { make, add, anims } = phaserUtils;\n  const tilemap = make.tilemap({\n    data: level,\n    tileWidth: 64,\n    tileHeight: 64,\n  });\n  const tiles = tilemap.addTilesetImage(\"tiles\");\n  const world = tilemap.createStaticLayer(0, tiles, 0, 0);\n  const player = world\n    .createFromTiles(Tiles.Player, 0, {\n      key: \"tiles\",\n      frame: Tiles.Player,\n    })\n    .pop();\n\n  assert(player);\n\n  player.setOrigin(0);\n\n  const boxesByColor = extractBoxes(world);\n\n  createPlayerAnimations(anims);\n\n  const movesCountText = add.text(540, 10, \"Moves: 0\");\n  return { player, world, boxesByColor, movesCountText };\n}\n\nconst extractBoxes = (\n  world: Phaser.Tilemaps.StaticTilemapLayer\n): BoxesByColor => {\n  const boxesByColor = BoxColors.reduce<BoxesByColor>((prev, boxColor) => {\n    prev[boxColor] = world\n      .createFromTiles(boxColor, 0, { key: \"tiles\", frame: boxColor })\n      .map((box) => box.setOrigin(0));\n\n    return prev;\n  }, {});\n\n  return boxesByColor;\n};\n\nfunction createPlayerAnimations(anims: Phaser.Animations.AnimationManager) {\n  anims.create({\n    key: \"idle-down\",\n    frames: [{ key: \"tiles\", frame: 52 }],\n  });\n  anims.create({\n    key: \"idle-left\",\n    frames: [{ key: \"tiles\", frame: 81 }],\n  });\n  anims.create({\n    key: \"idle-right\",\n    frames: [{ key: \"tiles\", frame: 78 }],\n  });\n  anims.create({\n    key: \"idle-up\",\n    frames: [{ key: \"tiles\", frame: 55 }],\n  });\n  anims.create({\n    key: \"left\",\n    frames: anims.generateFrameNumbers(\"tiles\", {\n      start: 81,\n      end: 83,\n    }),\n    frameRate: 10,\n    repeat: -1,\n  });\n  anims.create({\n    key: \"right\",\n    frames: anims.generateFrameNumbers(\"tiles\", {\n      start: 78,\n      end: 80,\n    }),\n    frameRate: 10,\n    repeat: -1,\n  });\n  anims.create({\n    key: \"up\",\n    frames: anims.generateFrameNumbers(\"tiles\", {\n      start: 55,\n      end: 57,\n    }),\n    frameRate: 10,\n    repeat: -1,\n  });\n  anims.create({\n    key: \"down\",\n    frames: anims.generateFrameNumbers(\"tiles\", {\n      start: 52,\n      end: 54,\n    }),\n    frameRate: 10,\n    repeat: -1,\n  });\n}\n","import Phaser from \"phaser\";\nimport { update } from \"./update\";\nimport { create } from \"./create\";\nimport { assert } from \"../utils/assert\";\n\nexport interface BoxesByColor {\n  [key: string]: Phaser.GameObjects.Sprite[];\n}\n\nexport interface Elements {\n  player: Phaser.GameObjects.Sprite;\n  world: Phaser.Tilemaps.StaticTilemapLayer;\n  boxesByColor: BoxesByColor;\n  movesCountText: Phaser.GameObjects.Text;\n}\n\nexport interface CreateUtils {\n  make: Phaser.GameObjects.GameObjectCreator;\n  anims: Phaser.Animations.AnimationManager;\n  add: Phaser.GameObjects.GameObjectFactory;\n}\n\nexport interface UpdateUtils {\n  scene: Phaser.Scenes.ScenePlugin;\n  cursors: Phaser.Types.Input.Keyboard.CursorKeys;\n  tweens: Phaser.Tweens.TweenManager;\n}\n\nexport class GameScene extends Phaser.Scene {\n  cursors?: Phaser.Types.Input.Keyboard.CursorKeys;\n  elements?: Elements;\n\n  constructor() {\n    super(\"Scene\");\n  }\n  preload = () => {\n    const { load } = this;\n    load.spritesheet(\"tiles\", \"assets/sokoban_tilesheet.png\", {\n      frameWidth: 64,\n      startFrame: 0,\n    });\n\n    this.cursors = this.input.keyboard.createCursorKeys();\n  };\n  create = () => {\n    const { make, anims, add } = this;\n    const phaserUtils: CreateUtils = { make, anims, add };\n\n    const elements = create(phaserUtils);\n\n    this.elements = elements;\n  };\n\n  update = () => {\n    const { cursors, tweens, elements, scene } = this;\n    assert(cursors);\n    const updateUtils: UpdateUtils = { cursors, tweens, scene };\n    assert(elements);\n    update({ updateUtils, elements });\n  };\n}\n","import Phaser from \"phaser\";\n\nexport default class LevelFinishedScene extends Phaser.Scene {\n  constructor() {\n    super(\"level-finished\");\n  }\n\n  create(data: { moves: number } = { moves: 0 }) {\n    const { width, height } = this.scale;\n    const { add } = this;\n    add.text(width * 0.5, height * 0.5, \"Level Complete!\", {\n      fontSize: 48,\n    });\n    add.text(width * 0.5, height * 0.5, `Moves: ${data.moves}`);\n  }\n}\n","import Phaser from \"phaser\";\nimport { GameScene } from \"../GameScene/GameScene\";\nimport LevelFinishedScene from \"./scenes/LevelFinishedScene\";\n\nvar config: Phaser.Types.Core.GameConfig = {\n  type: Phaser.AUTO,\n  width: 640,\n  height: 512,\n  physics: {\n    default: \"arcade\",\n    arcade: {\n      gravity: { y: 300 },\n      debug: false,\n    },\n  },\n  scene: [GameScene, LevelFinishedScene],\n  parent: \"phaser\",\n};\n\nconst game = new Phaser.Game(config);\n\nexport default game;\n"],"sourceRoot":""}